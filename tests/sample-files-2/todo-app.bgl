
from '../../lib/wrappers/core' import { iter }
from '../../lib/wrappers/local-storage' import { localStorage }
from '../../lib/wrappers/json' import { parse, stringify }

const lsKey = 'todo-list'

type TodoItemData = {
    text: string,
    done: boolean
}

class TodoItem {

    func constructor(item: TodoItemData) => TodoItem { item: item }

    private item: TodoItemData
    
    public func memo render() =>
        <div>
            <input value={item.text} onChange={this.handleItemTextChange(item)}></input>
            <input type={'checkbox'} checked={item.done} onChange={this.handleItemDoneChange(item)}></input>
        </div>
}

class TodoApp {
    
    public func memo render() =>
        <div>
            {iter<TodoItem>(this.todoItems())
                .map<Element>(item => item.render())
                .array()}

            <button onClick={this.addItem}>{'Add'}</button>
            <button onClick={this.clearDone}>{'Clear done'}</button>
        </div>

    private func memo todoItems() =>
        iter<TodoItemData>(this.items)
            .map<Element>(item => new TodoItem(item))
            .array()

    visible items: TodoItemData[] = (
        if (localStorage.getItem(lsKey) != nil) {
            parse(localStorage.getItem(lsKey))
        } else {
            []
        }
    )

    func memo handleItemTextChange(item: TodoItemData) =>
        (e) {
            item.text = e.target.value;
        }

    func memo handleItemDoneChange(item: TodoItemData) =>
        (e) {
            item.done = e.target.checked;
        }

    proc addItem() {
        this.items.push({ text: '', done: false });
    }

    proc clearDone() {
        this.items = iter<TodoItemData>(this.items).filter(item => item.done == false).array();
    }
}

proc main() {
    let app = new TodoApp();

    autorun () {
        localStorage.setItem(lsKey, stringify(app.items, 0));
    }
    forever;

    autorun () {
        ___render(app.render());
    }
    forever;
}