Design tasks:
- Dates
- Type-checking serializable data
- Rethink reactions (autorun? exprs vs functions for when-clause?)
- consts in procs
- consts in all expressions?

Implementation tasks:
- Generics
- Mutability levels as part of the type system
- Exhaustiveness checking in switch expressions
- Class member access-modifier checking

Gruntwork tasks:
- Build out standard libraries, including wrappers around browser APIs
- Various spread/destructuring syntaxes for objects, arrays, tuples, etc

Scattered thoughts:
- consts can't be allowed to capture mutable state! otherwise they may get stale
- can we identify everything that causes side-effects and force it all to happen 
in autoruns? note that this doesn't include all procs, because some 
only get invoked by others
    - Procs get triggered in one of a few ways:
        - Startup
        - Plan resolution
        - Events (UI, system, etc)
        - State changes (reactivity)
        - (other procs)
    - An action is a proc that changes state
    - A *re*action is a proc that reacts to state
    - Any given proc may respond to state and/or outside world, and then affect 
    state and/or outside world
    - Make sure effects on the outside world never get stale re: state?
    - Can we define *all* possible effects on the outside world? (Elm does...)
        - Triggering a Plan
        - Modifying the DOM
        - Modifying the location (really, any mutating browser API)
- We don't need a callback-based setTimeout; this should be a Plan
- objects can be (recursively) mutable or immutable; individual properties can't be
    - but scope bindings can separately be mutable or immutable (can have a 
    mutable reference to an immutable object type, etc)
        - *but* object literals will infer their mutability based on where 
        they're defined

- Class construction:
    - func constructor() is a pure function
    - It can take arguments, and expresses the class instance as 
    TheClass { prop1: prop1, prop2: prop2 }
    - Creation must populate all non-nillable properties that lack 
    default values
    - Code outside of the class can also use the above initialization style, 
    without a constructor?
        - But only if there are no private fields that lack default values! If 
        there are, the class *must* have a constructor.
    - Is constructor function special, or just a convention like ::new()? Do we
    just need some - any - function that returns an instance of the class?
        - Ah but it has to be special because how is it called?
            - Unless it lives outside of the class?