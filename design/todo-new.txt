Design tasks:
- Dates
- Type-checking serializable data
- Rethink reactions (autorun? exprs vs functions for when-clause?)
- consts in procs
- consts in all expressions?

Implementation tasks:
- Generics
- Mutability levels as part of the type system
- Exhaustiveness checking in switch expressions
- Class member access-modifier checking

Gruntwork tasks:
- Build out standard libraries, including wrappers around browser APIs
- Various spread/destructuring syntaxes for objects, arrays, tuples, etc

Scattered thoughts:
- consts can't be allowed to capture mutable state! otherwise they may get stale
- can we identify everything that causes side-effects and force it all to happen 
in autoruns? note that this doesn't include all procs, because some 
only get invoked by others
    - Procs get triggered in one of a few ways:
        - Startup
        - Plan resolution
        - Events (UI, system, etc)
        - State changes (reactivity)
        - (other procs)
    - An action is a proc that changes state
    - A *re*action is a proc that reacts to state
    - Any given proc may respond to state and/or outside world, and then affect 
    state and/or outside world
    - Make sure effects on the outside world never get stale re: state?
    - Can we define *all* possible effects on the outside world? (Elm does...)
        - Triggering a Plan
        - Modifying the DOM
        - Modifying the location (really, any mutating browser API)
- We don't need a callback-based setTimeout; this should be a Plan
- objects can be (recursively) mutable or immutable; individual properties can't be
    - but scope bindings can separately be mutable or immutable (can have a 
    mutable reference to an immutable object type, etc)
        - *but* object literals will infer their mutability based on where 
        they're defined

- Class construction:
    - func constructor() is a pure function
    - It can take arguments, and expresses the class instance as 
    TheClass { prop1: prop1, prop2: prop2 }
    - Creation must populate all non-nillable properties that lack 
    default values
    - Code outside of the class can also use the above initialization style, 
    without a constructor?
        - But only if there are no private fields that lack default values! If 
        there are, the class *must* have a constructor.
    - Is constructor function special, or just a convention like ::new()? Do we
    just need some - any - function that returns an instance of the class?
        - Ah but it has to be special because how is it called?
            - Unless it lives outside of the class?

- constraints on reactions:
    - effect can reference anything
    - data clause can only reference things that will get collected when the 
      reaction itself should get collected
        - local variables that don't escape the scope
        - private class members that don't escape the class
        - these can be passed to functions, but not to procs?
            - if there's no global state, they actually could be passed to procs
              (we'd know nothing could still be holding on to them)
            - most importantly, can't be assigned to anything passed into the 
              current scope from the outside
            - generally: the "outside world" can be reduced to a) proc args, and 
              b) global state (if we have that)
            - No global state to start, and think about adding it later?

Things we know about a value:
- Mutable or not in current context
- Mutable or not to *anybody*
    - Combined, three possible states: constant, readonly (currently), mutable
    - 2 and 3 will be observable; 1 should be boxed and could maybe be 
      optimized for immutability
- Owned by current scope or not
    - Must be a) created in local scope, and b) not leaked to parent proc or 
      global state
- Procs do or don't modify local (observable) state
  - Procs that don't modify local state modify the system and/or outside world
  - Reaction effects can *only* modify the outside world? This would prevent
    GC issues!
      - How do we demarcate procs and other operations that only modify the 
      outside world?
        - Ones with no mutable arguments? (every arg type is mutability !== "mutable")
          - Global application state would break this shortcut and make the 
            overall goal more complicated (but still possible!)

- Imba has explicit calls for starting a server, mounting an app, or even appending a child to an existing element

Features that exist but need more cases covered:
  - Type refinements (resolveRefinements/conditionToRefinement)
  - Generic inference (fitTemplate)
  - Type-resolution (resolveType)
  - Compiling static types to runtime types for instanceof calls (compileRuntimeType)
    - Need to also statically check that type used in instanceof is supported at runtime
    - Need to also normalize runtime types for aliased types
  - propertiesOf, for some more things like object-unions

- `if (cond) a else b` instead of `if cond { a } else { b }`?