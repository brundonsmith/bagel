
// what to do about modules?? JavaScript modules???


// -------- pure ----------

// implemented as { kind: TodoId, value: '' }
nominal type TodoId = string;

type Mode = 'all' | 'active' | 'completed';

type Todo = {
    id: TodoId,
    title: string,
    completed: bool,
}

// refactor: automatically convert function with no parameters to constant (warn/lint?)


// utilities for working with URL?

// better string and array utilities for sure

// better *standard library*

// auto-convert common typescript typings to our typings


func uuid(): string => '12345'

func classNames(cn: {[string]: boolean}): string =>
    cn
        |> entries 
        |> filter(([key, value]) => value == true) 
        |> fromEntries;


func renderFooter = (appState: AppState, count: number, completedCount: number): HTML =>
    <footer class='footer'>
        <span class='todo-count'>
            <strong>{count}</strong> item{if(count > 1) 's' else ''} left
        </span>
        <ul class='filters'>
            <li>
                <a
                    href='#/'
                    class={classNames({selected: nowShowing == 'all'})}>
                        All
                </a>
            </li>
            {' '}
            <li>
                <a
                    href='#/active'
                    class={classNames({selected: nowShowing == 'active'})}>
                        Active
                </a>
            </li>
            {' '}
            <li>
                <a
                    href='#/completed'
                    class={classNames({selected: nowShowing == 'completed'})}>
                        Completed
                </a>
            </li>
        </ul>
        {if (completedCount > 0)
            <button
                className="clear-completed"
                onClick={appState.clearCompleted}>
                Clear completed
            </button>}
    </footer>;

func renderItem = (todo: Todo): HTML =>
    <li class={classNames({
        completed: todo.completed,
        editing: editing
    })}>
        <div class='view'>
            <input
                class='toggle'
                type='checkbox'
                checked={todo.completed}
                onChange={this.props.onToggle}
            />
            <label onDoubleClick={this.handleEdit}>
                {this.props.todo.title}
            </label>
            <button class='destroy' onClick={this.props.onDestroy} />
        </div>
        <input
            ref='editField'
            class='edit'
            value={this.state.editText}
            onBlur={this.handleSubmit}
            onChange={this.handleChange}
            onKeyDown={this.handleKeyDown}
        />
    </li>;

func renderApp = (appState: AppState): HTML =>
   <div>
        <header class='header'>
            <h1>todos</h1>
            <input
                class='new-todo'
                placeholder='What needs to be done?'
                value={appState.newTodo}
                onKeyDown={handleNewTodoKeyDown(appState)}
                onChange={handleNewTodoChange(appState)}
                autoFocus={true}
            />
        </header>
        <section class='main'>
            <input
                id='toggle-all'
                class='toggle-all'
                type='checkbox'
                onChange={this.toggleAll}
                checked={activeTodoCount == 0}
            />
            <label
                htmlFor='toggle-all'
            />
            <ul class='todo-list'>
                {appState.todos |> map(renderItem)}
            </ul>
        </section>

        {renderFooter(appState)}

    </div>;


// Function modifiers:
// - memo (@computed)
// - conc (spins into worker thread) (classes make this problematic!)
// - async (is this redundant with Promise<>?)

// await operator automatically parallelizes as much as possible

// partial application of arguments


// -------- non-pure ----------

// const means recursive immutability?
// how to handle immutability in foreign objects?
// ban untyped foreign function calls from pure functions? can't guarantee they don't change state
// allow configuration of this?

class AppState {
    newTodo: string = '';
    nowShowing: Mode = 'all';
    todos: Todo[] = [];
    editing: TodoId|null = null;

    func memo shownTodos(this): Todo[] => 
        this.todos 
        |> filter(todo => 
            if (this.nowShowing == 'active') !todo.completed
            else if (this.nowShowing == 'completed') todo.completed
            else true)

    proc addTodo(this, title: string) {
        this.todos.push({
            id: uuid(),
            title: title,
            completed: false,
        });
    }

    proc toggleAll(this, completed: boolean) {        
        for (let todo of this.todos) {
            todo.completed = completed;
        }
    }

    proc toggle(this, id: TodoId) {
        for (let todo of appState.todos) {
            if (todo.id == id) {
                todo.completed = !todo.completed;
            }
        }
    }

    proc destroy(this, id: TodoId) {
        
    }

    proc clearCompleted(this) {
        this.todos = this.todos |> filter(todo => !todo.completed);
    }
}

const ENTER_KEY = 13;
const ESCAPE_KEY = 27;

proc handleNewTodoChange(appState: AppState, event: ChangeEvent) {
    appState.newTodo = event.target.value;
}

proc handleNewTodoKeyDown(appState: AppState, event: KeyDownEvent) {
    if (event.keyCode == ENTER_KEY) {
        event.preventDefault();

        const val = this.appState.newTodo |> trim;

        if (val.length > 0) {
            this.appState.addTodo(val);
            this.appState.newTodo = '';
        }
    }
}

proc handleToggleAllChange(appState: AppState, event: ChangeEvent) {
    const checked = event.target.checked;
    this.appState.toggleAll(checked);
}

proc handleToggleAllChange(appState: AppState, event: ChangeEvent) {
    const checked = event.target.checked;
    this.appState.toggleAll(checked);
}

proc handleTodoKeyDown(todo: Todo, event: KeyDownEvent) {
    if (event.which == ESCAPE_KEY) {
        this.setState({editText: this.props.todo.title});
        this.props.onCancel(event);
    } else if (event.which == ENTER_KEY) {
        this.handleSubmit(event);
    }
}

proc updateDom(html: HTML) {
    ...
}

// converts data structure to plain HTML for those who don't want to mess with 
// VDom (servers, for example)
func htmlString = (html: HTML): string =>
    ...

proc main() {
    let appState = new AppState();

    reaction! renderApp(appState) -> (html) { updateDom(html); };
}
